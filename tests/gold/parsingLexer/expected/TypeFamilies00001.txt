HaskellTokenType.module ('module')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('TypeFamilies00001')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- Mostly copy-pasta from https://stackoverflow.com/questions/20870432/type-family-vs-data-family-in-brief\n')
WHITE_SPACE ('\n')
HaskellTokenType.Synthetic leftbrace ('')
HaskellTokenType.class ('class')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMapKey')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic leftbrace ('')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.* ('*')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.* ('*')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.varidRegexp ('empty')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.varidRegexp ('lookup')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Maybe')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.varidRegexp ('insert')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('GMap')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('k')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('v')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.Synthetic rightbrace ('')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.class ('class')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Collects')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic leftbrace ('')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.varidRegexp ('empty')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.varidRegexp ('insert')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.varidRegexp ('member')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bool')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.varidRegexp ('toList')
WHITE_SPACE (' ')
HaskellTokenType.:: ('::')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
WHITE_SPACE (' ')
HaskellTokenType.-> ('->')
WHITE_SPACE (' ')
HaskellTokenType.[ ('[')
HaskellTokenType.conidRegexp ('Elem')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('ce')
HaskellTokenType.] (']')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.Synthetic rightbrace ('')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Foo')
WHITE_SPACE ('\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bar')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.class ('class')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('C')
WHITE_SPACE (' ')
HaskellTokenType.where ('where')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic leftbrace ('')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Foo')
WHITE_SPACE ('\n')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
WHITE_SPACE (' ')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bar')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- Declare a family of type synonyms, called `Element`\n')
HaskellTokenType.comment ('-- `Element` has kind `* -> *`; it takes one parameter, which we call `container`\n')
HaskellTokenType.Synthetic rightbrace ('')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Element')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('container')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- ByteString is a container for Word8, so...\n')
HaskellTokenType.comment ('-- The Element of a `S.ByteString` is a `Word8`\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Element')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('S')
HaskellTokenType.. ('.')
HaskellTokenType.conidRegexp ('ByteString')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Word8')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- and the Element of a `L.ByteString` is also `Word8`\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.type ('type')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Element')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('L')
HaskellTokenType.. ('.')
HaskellTokenType.conidRegexp ('ByteString')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Word8')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- Declare a list-like data family\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.family ('family')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.varidRegexp ('a')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- Declare a list-like instance for Char\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Char')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XCons')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Char')
WHITE_SPACE (' ')
HaskellTokenType.( ('(')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Char')
HaskellTokenType.) (')')
WHITE_SPACE (' ')
HaskellTokenType.| ('|')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XNil')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- Declare a number-like instance for ()\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('()')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XListUnit')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Int')
WHITE_SPACE ('\n')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- ERROR: "Multiple declarations of `XListUnit'"\n')
HaskellTokenType.Synthetic semicolon ('')
HaskellTokenType.data ('data')
WHITE_SPACE (' ')
HaskellTokenType.instance ('instance')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XList')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('()')
WHITE_SPACE (' ')
HaskellTokenType.= ('=')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('XListUnit')
WHITE_SPACE (' ')
HaskellTokenType.conidRegexp ('Bool')
WHITE_SPACE ('\n')
HaskellTokenType.comment ('-- (Note: GHCI accepts this; the new declaration just replaces the previous one.)')
HaskellTokenType.Synthetic rightbrace ('')